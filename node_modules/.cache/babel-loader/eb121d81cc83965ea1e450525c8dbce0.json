{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.trackPromise = exports.promiseCounterUpdateEventId = exports.manuallyResetPromiseCounter = exports.manuallyIncrementPromiseCounter = exports.manuallyDecrementPromiseCounter = exports.getCounter = exports.emitter = void 0;\n\nvar _tinyEmmiter = require(\"./tinyEmmiter\");\n\nvar _constants = require(\"./constants\");\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar emitter = new _tinyEmmiter.Emitter();\nexports.emitter = emitter;\nvar promiseCounterUpdateEventId = \"promise-counter-update\";\nexports.promiseCounterUpdateEventId = promiseCounterUpdateEventId;\n\nvar counter = _defineProperty({}, _constants.defaultArea, 0);\n\nvar getCounter = function getCounter(area) {\n  return counter[area];\n};\n\nexports.getCounter = getCounter;\n\nvar trackPromise = function trackPromise(promise, area) {\n  area = area || _constants.defaultArea;\n  incrementPromiseCounter(area);\n\n  var onResolveHandler = function onResolveHandler() {\n    return decrementPromiseCounter(area);\n  };\n\n  promise.then(onResolveHandler, onResolveHandler);\n  return promise;\n};\n\nexports.trackPromise = trackPromise;\n\nvar incrementPromiseCounter = function incrementPromiseCounter(area) {\n  incrementCounter(area);\n  var promiseInProgress = anyPromiseInProgress(area);\n  emitter.emit(promiseCounterUpdateEventId, promiseInProgress, area);\n};\n\nvar incrementCounter = function incrementCounter(area) {\n  if (Boolean(counter[area])) {\n    counter[area]++;\n  } else {\n    counter[area] = 1;\n  }\n};\n\nvar anyPromiseInProgress = function anyPromiseInProgress(area) {\n  return counter[area] > 0;\n};\n\nvar decrementPromiseCounter = function decrementPromiseCounter(area) {\n  counter[area] > 0 && decrementCounter(area);\n  var promiseInProgress = anyPromiseInProgress(area);\n  emitter.emit(promiseCounterUpdateEventId, promiseInProgress, area);\n};\n\nvar decrementCounter = function decrementCounter(area) {\n  counter[area]--;\n};\n\nvar manuallyResetPromiseCounter = function manuallyResetPromiseCounter(area) {\n  area = area || _constants.defaultArea;\n  counter[area] = 0;\n  emitter.emit(promiseCounterUpdateEventId, false, area);\n};\n\nexports.manuallyResetPromiseCounter = manuallyResetPromiseCounter;\n\nvar manuallyDecrementPromiseCounter = function manuallyDecrementPromiseCounter(area) {\n  area = area || _constants.defaultArea;\n  decrementPromiseCounter(area);\n};\n\nexports.manuallyDecrementPromiseCounter = manuallyDecrementPromiseCounter;\n\nvar manuallyIncrementPromiseCounter = function manuallyIncrementPromiseCounter(area) {\n  area = area || _constants.defaultArea;\n  incrementPromiseCounter(area);\n}; // TODO: Enhancement we could catch here errors and throw an Event in case there's an HTTP Error\n// then the consumer of this event can be listening and decide what to to in case of error\n\n\nexports.manuallyIncrementPromiseCounter = manuallyIncrementPromiseCounter;","map":{"version":3,"names":["Object","defineProperty","exports","value","trackPromise","promiseCounterUpdateEventId","manuallyResetPromiseCounter","manuallyIncrementPromiseCounter","manuallyDecrementPromiseCounter","getCounter","emitter","_tinyEmmiter","require","_constants","_defineProperty","obj","key","enumerable","configurable","writable","Emitter","counter","defaultArea","area","promise","incrementPromiseCounter","onResolveHandler","decrementPromiseCounter","then","incrementCounter","promiseInProgress","anyPromiseInProgress","emit","Boolean","decrementCounter"],"sources":["/home/sl/Desktop/Project4/New Folder/Robofriends2/node_modules/react-promise-tracker/lib/trackPromise.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.trackPromise = exports.promiseCounterUpdateEventId = exports.manuallyResetPromiseCounter = exports.manuallyIncrementPromiseCounter = exports.manuallyDecrementPromiseCounter = exports.getCounter = exports.emitter = void 0;\nvar _tinyEmmiter = require(\"./tinyEmmiter\");\nvar _constants = require(\"./constants\");\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nvar emitter = new _tinyEmmiter.Emitter();\nexports.emitter = emitter;\nvar promiseCounterUpdateEventId = \"promise-counter-update\";\nexports.promiseCounterUpdateEventId = promiseCounterUpdateEventId;\nvar counter = _defineProperty({}, _constants.defaultArea, 0);\nvar getCounter = function getCounter(area) {\n  return counter[area];\n};\nexports.getCounter = getCounter;\nvar trackPromise = function trackPromise(promise, area) {\n  area = area || _constants.defaultArea;\n  incrementPromiseCounter(area);\n  var onResolveHandler = function onResolveHandler() {\n    return decrementPromiseCounter(area);\n  };\n  promise.then(onResolveHandler, onResolveHandler);\n  return promise;\n};\nexports.trackPromise = trackPromise;\nvar incrementPromiseCounter = function incrementPromiseCounter(area) {\n  incrementCounter(area);\n  var promiseInProgress = anyPromiseInProgress(area);\n  emitter.emit(promiseCounterUpdateEventId, promiseInProgress, area);\n};\nvar incrementCounter = function incrementCounter(area) {\n  if (Boolean(counter[area])) {\n    counter[area]++;\n  } else {\n    counter[area] = 1;\n  }\n};\nvar anyPromiseInProgress = function anyPromiseInProgress(area) {\n  return counter[area] > 0;\n};\nvar decrementPromiseCounter = function decrementPromiseCounter(area) {\n  counter[area] > 0 && decrementCounter(area);\n  var promiseInProgress = anyPromiseInProgress(area);\n  emitter.emit(promiseCounterUpdateEventId, promiseInProgress, area);\n};\nvar decrementCounter = function decrementCounter(area) {\n  counter[area]--;\n};\nvar manuallyResetPromiseCounter = function manuallyResetPromiseCounter(area) {\n  area = area || _constants.defaultArea;\n  counter[area] = 0;\n  emitter.emit(promiseCounterUpdateEventId, false, area);\n};\nexports.manuallyResetPromiseCounter = manuallyResetPromiseCounter;\nvar manuallyDecrementPromiseCounter = function manuallyDecrementPromiseCounter(area) {\n  area = area || _constants.defaultArea;\n  decrementPromiseCounter(area);\n};\nexports.manuallyDecrementPromiseCounter = manuallyDecrementPromiseCounter;\nvar manuallyIncrementPromiseCounter = function manuallyIncrementPromiseCounter(area) {\n  area = area || _constants.defaultArea;\n  incrementPromiseCounter(area);\n};\n// TODO: Enhancement we could catch here errors and throw an Event in case there's an HTTP Error\n// then the consumer of this event can be listening and decide what to to in case of error\nexports.manuallyIncrementPromiseCounter = manuallyIncrementPromiseCounter;"],"mappings":"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"},"metadata":{},"sourceType":"script"}